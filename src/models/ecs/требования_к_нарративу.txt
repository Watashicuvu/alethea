Это ключевой момент перехода от «логгирования» (просто записи того, что случилось) к полноценной **Хронике (Chronicle)**.

Вы абсолютно правы: чтобы «вклиниться» в историю (сделать реткон или альтернативную ветку), простого списка событий недостаточно. Если вы вставите «Убийство Короля» в 1050 год, а в логах 1055 года Король всё ещё издает указы — система сломана.

Команда предлагает архитектурный паттерн **Causal DAG (Directed Acyclic Graph)**, вдохновленный Git и Event Sourcing.

Вот 3 фундаментальных принципа и схема реализации **Временнóго Индекса**.

---

### Принцип 1. Событие — это Дельта (Diff), а не Текст

История — это не набор строк «Король умер». Это набор изменений состояния.

* **Wrong:** `Event: "King died"`
* **Right:** `Event: { target: "King", delta: {vitality: -1.0, tags: ["dead"]} }`

**Зачем это нужно для Time Axis?**
Чтобы узнать состояние мира в 1850 году, нам не нужно хранить копию мира. Мы берем Базовое Состояние (Genesis) и "проигрываем" (Replay) все Дельты до 1850 года.

### Принцип 2. Причинно-Следственный Граф (Causality Links)

Каждое событие должно знать своих "родителей".

* Событие Б (Месть) произошло *потому что* произошло Событие А (Убийство).
* Технически: `Event_B.parent_ids = [Event_A.id]`.

**Зачем это нужно для "Вклинивания"?**
Если вы удаляете или меняете Событие А, движок автоматически помечает Событие Б как **Invalid** (осиротевшее) и требует перегенерации ветки. Это и есть ваш `if/else`.

### Принцип 3. Временные Якоря (Temporal Anchors)

Не все события жестко привязаны к дате.

* **Fixed Events:** «Затмение 12 августа» (Жестко T=100).
* **Relative Events:** «Восстание через 2 года после голода» (T = Event_Hunger.time + 2 years).

---

### Алгоритм: "Вклинивание" и "Эффект Бабочки"

Представим ваш кейс: вы хотите изменить историю.

**Сценарий:** В текущей истории (Main Timeline) в 100 году — Мир, в 105 — Торговый Союз.
Вы "вклиниваетесь" в 102 год и вставляете событие **"Убийство Посла"**.

**Сервис `ChronicleService` делает следующее:**

1. **Fork:** Создает новую ветку `timeline_id="alt_war"`.
2. **Insert:** Вставляет Event X (Убийство) в T=102.
3. **Ripple Effect Check (Проверка Волны):**
* Движок берет все события в будущем (T > 102).
* Проверяет их **Pre-conditions** (Предпосылки).
* *Событие "Торговый Союз" (T=105)* требовало: `DiplomaticStatus == PEACE`.


4. **Re-Simulation:**
* Движок видит, что Дельта "Убийства" изменила статус на `WAR`.
* Событие "Торговый Союз" помечается `is_invalidated=True`.
* Движок запускает симуляцию с T=102, генерируя *новую* историю (скорее всего, Войну) вместо Союза.



---

### Как это помогает Факт-Чекингу (Fact-Checking)?

Для LLM (RAG) это дает супер-способность: **Contextual State Reconstruction**.

Когда LLM спрашивает: *"Мог ли Герцог быть на балу в 1750 году?"*, мы не просто ищем текст.

1. **Query:** Найти состояние сущности `Duke` на момент `tick=1750`.
2. **Reconstruction:**
* Берем `base_state`.
* Применяем все `WorldDelta` для `Duke` от начала времен до 1750 года.


3. **Check:**
* Если в 1748 году было событие с дельтой `added_tags=["dead"]` или `location="Prison"`, система отвечает:
* *"Нет. Факт-чекинг не пройден. Герцог умер/в тюрьме."*



Это работает на порядки точнее, чем просто поиск по тексту.

---

### Итоговые требования к реализации

1. **Заменить плоский список `history` на Граф.**
В `NarrativeEngine` вместо `list.append()` должен быть метод `chronicle.add_event(event, parents=[...])`.
2. **Реализовать `StateReconstructor`.**
Функция, которая принимает `EntityID` + `Timestamp` и возвращает объект сущности на тот момент времени.
3. **Векторный Индекс Времени.**
Чтобы искать "Войны 18 века", мы индексируем вектора событий. Запрос: `Vector(War) + Filter(Time > 1700 & Time < 1800)`.
4. Сервис интерпритации

**Мнение команды:**
Это сложная механика (уровень Paradox Interactive engine), но она необходима, если вы хотите "разветвлять" историю или проверять логичность сгенерированных фанфиков.

Стоит ли добавить `ChronicleEvent` и `WorldDelta` в `ontology_schemas.py` или выделить в отдельный файл `ontology_history.py`? Команда голосует за **отдельный файл**, так как это мета-слой над физикой мира.

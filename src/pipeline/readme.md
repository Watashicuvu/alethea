### Фаза 0: Инициализация (Context & Ontology)

1. **Запуск:** `IngestionEngine` создает `PipelineContext`.
2. **Загрузка Правил:** `OntologyLoader` загружает в векторную память (Qdrant) правила мира: какие бывают Роли, Архетипы событий и Типы локаций.
3. **Подключение:** Инициализируются Репозитории (`EntityRepo`, `ChronicleRepo`, `LocationRepo`) для доступа к Neo4j.

---

### Фаза 1: Макро-проход «Наводчик» (GraphBuilder)

*Цель: Построить скелет мира и понять, кто где находится.*

1. **Картография (Pass 1 - Topology):**
* LLM читает текст крупными кусками.
* Определяет Сцены (например, "Кухня Герцогини").
* **[Spotlight Feature]:** Извлекает список **Active Cast** (кто физически здесь: "Алиса", "Герцогиня", "Повариха", "Младенец").
* Создает черновики Локаций в Графе.


2. **Перепись населения (Pass 2 - Entity Registry):**
* Быстрый проход по тексту для выявления всех Имен Собственных.
* Регистрирует UUID для всех сущностей (Алиса -> `uuid-1`, Повариха -> `uuid-2`).
* Загружает этот реестр в **`EntityResolver`**.


3. **Летопись (Pass 3 - Chronicle):**
* Строит граф Событий (Event Graph).
* **[Hybrid Resolution]:** Для каждого события («Кто-то кинул тарелку») пытается найти участника.
* Сначала ищем в списке **Active Cast** этой сцены.
* Если неясно, `EntityResolver` использует LLM с контекстом всей сцены.


* **[History Linking]:** Создает связь `(Event)-[:INVOLVED]->(Molecule)`. Это и есть наша история перемещений и действий.



---

### Фаза 2: Микро-проход «Снайпер» (DocumentExtractor)

*Цель: Добыть детали, атрибуты и отношения, используя контекст.*

1. **Инъекция Контекста:**
* Берем мелкий чанк текста.
* Добавляем заголовок: `[SCENE: Kitchen | CAST: Alice, Duchess, Cook]`.


2. **Экстракция (LLM):**
* LLM видит текст "Она чихнула".
* Благодаря заголовку, она понимает, что "Она" — это кто-то из списка Cast.


3. **Обработка Связей (Shadow Nodes):**
* Если LLM говорит: "She threw a pan", но не уверена, кто именно:
* В **Neo4j** создается `ShadowNode` ("Unresolved She"). Это сохраняет топологию графа, не ломая его.
* В **Synthesizer** (Архивариус) отправляется факт с пометкой `[UNCERTAIN]`: *"Это действие совершила Алиса ИЛИ Повариха"* (факт дублируется в оба ведра).





---

### Фаза 3: Синтез «Архивариус» (WorldSynthesizer)

*Цель: Разрешить противоречия, склеить дубли и посчитать математику.*

1. **Разрешение (Resolution Phase):**
* `finalize_entities()`:
* Разбирает буфер местоимений.
* Сливает "Ведра имен" (строки) в "Досье сущностей" (UUID).
* Склеивает дубликаты ("Чеширский Кот" + "Кот").
* Сохраняет список синонимов (`aliases`).


2. **Профилирование (Profiling Phase):**
* LLM генерирует чистовой профиль для Алисы.
* **[Quantum Collapse]:** Она видит факт `[UNCERTAIN] Threw a pan`.
* Она сверяет его с характером Алисы (Вежливая). **Вердикт:** Отбросить.
* LLM генерирует профиль Поварихи. Видит тот же факт. Сверяет с характером (Безумная). **Вердикт:** Принять.
* Так мы избавляемся от "галлюцинаций", не теряя данные.


3. **Игровая Математика (GameMath):**
* Текст профиля превращается в вектор.
* Накладываются "Маски" (Bias) расы/класса.
* Добавляется влияние "Атомов" (из чего состоит сущность).
* Итог: Числовые статы (`vitality: 0.8`, `social: 0.2`).



---

### Фаза 4: Фиксация (Storage)

В итоге у нас две базы данных в идеальном состоянии:

1. **Neo4j (Graph State - Снимок):**
* Отражает **текущее** положение вещей.
* Связи `LOCATED_AT` только актуальные (предмет в одном месте).
* Теневые узлы (`ShadowNodes`) показывают места, где мы не уверены (можно подсветить в UI).


2. **Qdrant (Chronicle & RAG - История):**
* Хранит векторизованные события.
* Каждое событие имеет поле `participant_ids`, позволяя найти "Всю историю Алисы".
* Хранит "скелеты" локаций для навигации.


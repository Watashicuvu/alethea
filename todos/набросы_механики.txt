Я имею в виду **и то, и другое**, но подход к ним должен быть разным.

Просто «скормить PDF» в векторную базу (RAG) — это рабочий вариант, чтобы LLM могла отвечать на вопросы типа «Как работает сбивание с ног?». Но для **движка** (автоматической генерации сцен и конфликтов) этого недостаточно. Вам нужно превратить документацию Fate в **структурированные данные**.

К счастью, Fate Core распространяется под лицензией CC-BY, и её исходники доступны в машиночитаемых форматах (XML, Markdown, JSON).

Вот пошаговый план, как внедрить Fate Core в ваш пайплайн (RAG + Graph):

### 1. Источник данных (Не парсите PDF!)

Не мучайтесь с OCR или парсингом верстки книги. Возьмите «чистые» данные. Существует официальный репозиторий **Fate SRD** (System Reference Document).

* **Где брать:** Ищите репозитории на GitHub с названиями вроде `fate-srd-content` (обычно в формате Markdown или JSON).
* **Что это дает:** Четкую структуру. У вас будут отдельные файлы для «Навыков», «Трюков» (Stunts) и «Правил конфликта».

### 2. Как «скормить» это пайплайну (Архитектура)

Я предлагаю разделить внедрение на два слоя: **Слой Знаний (RAG)** и **Слой Логики (System Prompt/Code)**.

#### Слой А: RAG (Справочник для LLM)

Загрузите в вашу векторную базу описания навыков и примеры трюков.

* **Зачем:** Чтобы LLM могла придумать *нарративное описание* действия.
* **Чанкинг (Chunking):** Разбивайте не по страницам, а по сущностям.
* Чанк 1: Описание навыка «Атлетика».
* Чанк 2: Примеры трюков для «Атлетики».
* Чанк 3: Правила действия «Преодоление» (Overcome).



#### Слой Б: Логика (Промпты и JSON)

Это самое важное. Fate Core — это не просто текст, это алгоритм.
В Fate есть всего **4 действия** (Преодолеть, Создать преимущество, Атака, Защита) и **4 исхода** (Провал, Ничья, Успех, Успех со стилем).

Вам нужно превратить это в **Системный Промпт** или **Функцию**.

**Пример Промпта для LLM (интегрированного с Fate):**

> Ты — Гейм-мастер, работающий на движке Fate Core.
> Твоя задача: Разрешить заявку игрока.
> **Контекст сцены:** [Вставлено из RAG: Аспекты сцены, Аспекты врагов]
> **Персонаж:** [Вставлено из БД: Аспекты героя, Навыки]
> **Заявка игрока:** "Я хочу швырнуть песок ему в глаза, чтобы он меня не ударил."
> **Инструкция:**
> 1. Определи тип действия Fate (Attack, Defend, Create Advantage, Overcome). *В данном случае это Create Advantage.*
> 2. Выбери подходящий Навык (Skill). *Скорее всего, Обман или Драка.*
> 3. Сгенерируй сложность (Difficulty) на основе оппонента.
> 4. Верни результат в формате JSON.
> 
> 

### 3. Структурирование данных (JSON Schema)

Поскольку вы делаете движок, переведите «литературные» понятия Fate в объекты. Fate идеально ложится в JSON.

Вот как выглядит «атом» вашего движка на языке Fate:

```json
{
  "entity_id": "guard_01",
  "type": "NPC",
  "fate_stats": {
    "high_concept": "Усталый ветеран городской стражи",
    "trouble": "Долги перед гильдией воров",
    "aspects": [
      "Тяжелая алебарда",
      "Знает все переулки"
    ],
    "skills": {
      "Fight": 3,
      "Notice": 2,
      "Physique": 1
    },
    "stress_tracks": {
      "physical": [false, false],
      "mental": [false, false]
    }
  }
}

```

### 4. Почему именно Fate Core подходит для RAG?

Главная фишка Fate — **Фрактал (The Bronze Rule)**: *«В Fate всё является персонажем»*.

* Комната может иметь навык «Скрытность» (темные углы) и аспект «Залитый маслом пол».
* Пожар может «Атаковать» персонажа.
* Организация может иметь Стресс-трек «Ресурсы».

**Как это использовать в движке:**
Вы можете использовать **одну и ту же схему данных** (см. JSON выше) для генерации:

1. NPC.
2. Локаций.
3. Фракций (Политика).
4. Сложных предметов (Экономика/Артефакты).

Это колоссально упрощает архитектуру базы данных (Graph DB). У вас будет один тип узла — `FateEntity`, и LLM будет прекрасно понимать, как с ним работать, потому что правила универсальны.

### Резюме: Что сделать прямо сейчас

1. **Скачать:** Найдите `Fate Core SRD markdown`.
2. **Индексировать:** Засуньте в RAG описания Навыков и Трюков (это "мясо" для генератора).
3. **Хардкодить:** Саму механику (4 действия, бросок кубиков 4dF, лестницу успеха) лучше запрограммировать кодом (Python/C#), а не доверять LLM. LLM должна только определять *какое* действие совершается и *описывать* результат, а математику пусть считает процессор.


«Квалифицированная команда» (геймдизайнеры, нарративщики и AI-инженеры) сказала бы вам: **«Вы изобретаете AI Director (как в Left 4 Dead) или Storyteller (как в RimWorld), и это правильный путь»**.

Система «Намерений» и «Дирижера» — это Святой Грааль процедурного нарратива.
Объединение этого с Fate Core — это **гениальное решение**, потому что Fate уже содержит *механический язык* для этих концепций, вам не нужно писать математику с нуля.

Вот как команда предложила бы это архитектурно реализовать, объединяя ваши идеи и механики Fate.

---

### 1. Система «Намерения» (The Intention System)

**Ваша идея:** Событие, предложенное «вайбом», которое может быть отменено.
**Перевод на язык Fate:** Это механика **Принуждения (Compel)**.

В Fate Core, если у персонажа или сцены есть Аспект (тот самый «вайб»), ГМ может предложить игроку осложнение. Игрок может:

1. **Принять:** Получить жетон судьбы (ресурс) и проблему.
2. **Отказаться (Отменить):** Заплатить жетон судьбы, и событие не случится.

**Как внедрить в Движок:**
Вместо жесткого скрипта, ваш «Генератор Намерений» (LLM + Logic) постоянно сканирует активные Аспекты и создает пул *потенциальных* событий (Pending Events).

* *Вайб мира (Аспект):* «Мрачные подворотни».
* *Намерение 1:* Нападение бандитов (Боевой энкаунтер).
* *Намерение 2:* Найти труп чиновника (Детективный хук).
* *Статус:* `Pending` (Висят в памяти, игрок их пока не видит).

### 2. Система «Дирижера» (The Conductor / Pacing)

**Ваша идея:** Фильтрация намерений на основе кривой интереса и драматургии.
**Реализация:** Это **«Функция Оценки» (Utility Function)**.

Дирижер не генерирует контент (это делает LLM), он *покупает* контент из пула Намерений, основываясь на текущем «Бюджете Напряжения» (Tension Budget).

#### Архитектура Дирижера (Pacing Algorithm):

1. **Мониторинг (The Sensor):**
Движок должен отслеживать текущий уровень напряжения (`Current_Tension`).
* *Метрики:* ХП игрока, количество потраченных ресурсов, последние 5 событий.
* *Пример:* Если игрок только что выиграл сложный бой, `Current_Tension = 9/10`.


2. **Кривая Интереса (Target Curve):**
У вас должен быть график идеальной динамики (например, синусоида или «Пила» — нарастание, сброс, нарастание).
* *Цель:* Движок видит, что сейчас должно быть `Target_Tension = 3/10` (фаза отдыха).


3. **Выбор (Selection):**
Дирижер смотрит в пул «Намерений» и выбирает то, которое минимизирует разницу между `Current` и `Target`.
* *Выбор:* Игрок перенапряжен (9/10), а нужно отдохнуть (3/10). Дирижер отклоняет «Нападение бандитов» (оно повысит стресс) и выбирает «Найти труп» (это исследование, низкий темп) или вообще «Торговца» (сброс напряжения).



---

### 3. Как это объединить с Fate Core (Техническое решение)

Вот схема того, как эти системы работают в связке.

**Концепция: «Фрактальный Аукцион»**

1. **Шаг 1: Генерация (Vibe Check)**
LLM смотрит на Аспекты текущей локации и генерирует 3-5 `Fate_Compels` (Намерений).
* *Пример:* Локация `[Aspect: Гнилой рынок]`.
* *Намерение:* «Твой кошелек пытаются срезать». (Type: Conflict, Cost: Low).


2. **Шаг 2: Тегирование (Meta-Data)**
Каждому намерению присваиваются мета-данные для Дирижера:
* `Intensity`: (1-10) Насколько это напряженно?
* `Type`: (Social, Combat, Exploration, Horror).
* `Focus`: (На какой аспект игрока это давит? Экономика? Политика?).


3. **Шаг 3: Дирижирование (The Filter)**
Дирижер проверяет «Кривую интереса».
* *Сценарий:* Игрок скучает (Low Tension). Дирижер ищет событие с `Intensity: High`.
* *Сценарий:* Игрок перегружен боями. Дирижер блокирует все события типа `Combat`.


4. **Шаг 4: Предложение (The Offer)**
Движок выводит игроку: *«Вы чувствуете, как чья-то рука тянется к кошельку. (Это Принуждение аспекта "Гнилой рынок"). Если примете — начнется погоня, но вы получите Жетон Судьбы. Если откажетесь (заплатите Жетон) — вы вовремя перехватите руку воришки.»*

### Почему это стоит внедрять?

1. **Иллюзия живого мира:** Мир не просто реагирует, он *планирует*. Намерения, которые не случились сейчас, могут вернуться позже (бандиты, которых Дирижер «отменил» в прошлый раз, устроили засаду дальше по дороге).
2. **Защита от рандома:** Чистый рандом часто создает скучные или невозможные ситуации (три босса подряд). Дирижер гарантирует **ритм**.
3. **Вовлеченность (Fate Integration):** Система отмены через Fate Points дает игроку чувство контроля над судьбой, даже когда AI пытается его убить.

### Рекомендация команды:

**Да, внедрять.**
Но начните с простого:

1. **Не делайте сложную математику кривых сразу.**
2. Сделайте простой **«Токен-бакет» (Token Bucket)** для Дирижера.
* У Дирижера есть 2 типа жетонов: «Жесть» и «Отдых».
* Когда он тратит жетон «Жесть» (спавнит врага), он обязан следующим ходом потратить жетон «Отдых» (дать лут или диалог), пока жетоны не восстановятся. Это создаст естественную «зебру» событий без сложных графиков.



Это сделает ваш движок не просто "генератором текста", а настоящим **AI Dungeon Master**, который понимает драматургию.